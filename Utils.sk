import:
  java.nio.file.DirectoryStream
  java.nio.file.Files
  java.util.ArrayList
  java.io.File
function Time_durationBetweenUnix(time1: integer, time2: integer) :: string:
  set {_parsedTime1} to Instant.ofEpochSecond({_time1})
  set {_parsedTime2} to Instant.ofEpochSecond({_time2})
  set {_duration} to Duration.between({_parsedTime1}, {_parsedTime2})
  if {_duration}.toDays() > 0:
    return "%{_duration}.toDays()% days"
  if {_duration}.toHours() > 0:
    return "%{_duration}.toHours()% hours"
  if {_duration}.toMinutes() > 0:
    return "%{_duration}.toMinutes()% minutes"
  return "%{_duration}.toSeconds()% seconds"
function File_formatFileList(fileList: string) :: strings:
  set {_files::*} to split {_fileList} by ","
  set {_formattedFiles::*} to new ArrayList()
  loop {_files::*}:
    set {_file} to loop-value
    replace all "[" in {_file} with ""
    replace all "]" in {_file} with ""
    replace first " " in {_file} with ""
    add {_file} to {_formattedFiles::*}
  return {_formattedFiles::*}
function List_removeEmptyEntries(list: strings) :: strings:
  set {_formattedList::*} to new ArrayList()
  loop {_list::*}:
    if loop-value != "":
      add loop-value to {_formattedList::*}
  return {_formattedList::*}
function File_recGetFilesInDir(path: string) :: strings:
  set {_file} to new File({_path})
  set {_files} to {_file}.listFiles()
  set {_files::*} to File_formatFileList("%{_files}%")
  loop {_files::*}:
    add 1 to {_i}
    if {_i} > 100:
      return List_removeEmptyEntries({_formattedFiles::*})
    set {_fileCast} to new File(loop-value)
    if {_fileCast}.isFile():
      add loop-value to {_formattedFiles::*}
    else:
      set {_subFiles::*} to File_recGetFilesInDir(loop-value)
      add {_subFiles::*} to {_formattedFiles::*}
  return List_removeEmptyEntries({_formattedFiles::*})
function Number_parse(val: number) :: text:
  set {_val} to "%{_val}%"
  set {_val::*} to ({_val} split by ".")
  if length of {_val::1} > 3:
    if {_val::2} is set:
      return "%Number_parse(first length of {_val::1} - 3 characters of {_val::1})%,%last 3 characters of {_val::1}%.%{_val::2}%"
    return "%number_Parse(first length of {_val::1} - 3 characters of {_val::1})%,%last 3 characters of {_val::1}%"
  return {_val}
function Text_toSmallFont(text: string) :: string:
  clear {_chars::*}
  add "a=ᴀ" to {_chars::*}
  add "b=ʙ" to {_chars::*}
  add "c=ᴄ" to {_chars::*}
  add "d=ᴅ" to {_chars::*}
  add "e=ᴇ" to {_chars::*}
  add "f=ꜰ" to {_chars::*}
  add "g=ɢ" to {_chars::*}
  add "h=ʜ" to {_chars::*}
  add "i=ɪ" to {_chars::*}
  add "j=ᴊ" to {_chars::*}
  add "k=ᴋ" to {_chars::*}
  add "l=ʟ" to {_chars::*}
  add "m=ᴍ" to {_chars::*}
  add "n=ɴ" to {_chars::*}
  add "o=ᴏ" to {_chars::*}
  add "p=ᴘ" to {_chars::*}
  add "q=ǫ" to {_chars::*}
  add "r=ʀ" to {_chars::*}
  add "s=ѕ" to {_chars::*}
  add "t=ᴛ" to {_chars::*}
  add "u=ᴜ" to {_chars::*}
  add "v=ᴠ" to {_chars::*}
  add "w=ᴡ" to {_chars::*}
  add "x=х" to {_chars::*}
  add "y=ʏ" to {_chars::*}
  add "z=ᴢ" to {_chars::*}
  add "0=₀" to {_chars::*}
  add "1=₁" to {_chars::*}
  add "2=₂" to {_chars::*}
  add "3=₃" to {_chars::*}
  add "4=₄" to {_chars::*}
  add "5=₅" to {_chars::*}
  add "6=₆" to {_chars::*}
  add "7=₇" to {_chars::*}
  add "8=₈" to {_chars::*}
  add "9=₉" to {_chars::*}
  add ":=:" to {_chars::*}
  set {_text::*} to split {_text} at ""
  set {_output} to ""
  loop ({_text::*}):
    add 1 to {_i}
    set {_char} to loop-value
    loop {_chars::*}:
      set {_split::*} to split loop-value-2 by "="
      if {_text::%{_i} - 1%} = "&": 
        set {_outChar} to {_char}
        stop loop
      if {_char} = "<":
        set {_openTag} to true
      if {_openTag} = true:
        set {_outChar} to {_char}
        if {_char} = ">":
          set {_openTag} to false
          stop loop
        stop loop
      if {_char} = {_split::1}:
        set {_outChar} to {_split::2}
        stop loop
      else:
        set {_outChar} to {_char}
    set {_output} to "%{_output}%%{_outChar}%"
  return {_output}
function Test_announce(test_id: string, success: boolean = true):
  if {_success} = true:
    set {_prefix} to "✔"
    set {_color} to "&a"
    set {_text} to "succeeded"
    set {_matched} to "matched"
  else:
    set {_prefix} to "✖"
    set {_color} to "&c"
    set {_text} to "failed"
    set {_matched} to "did not match"
  broadcast "%{_color}%%{_prefix}% &7Test %{_color}%%{_test_id}% &7%{_text}%. Value %{_color}%%{-tests::%{_test_id}%::value}% &7%{_matched}% %{_color}%%{-tests::%{_test_id}%::expected}%&7."
  delete {-tests::%{_test_id}%::*}
function Server_getPath() :: string:
  return new File(".").getCanonicalPath()
function File_preventBacktracking(path: string) :: string:
  if {_path} contains "..":
    replace all ".." in {_path} with ""
  if {_path} starts with "/":
    replace first "/" in {_path} with ""
  return {_path}
function Text_concat(str1: string = "", str2: string = "", str3: string = "", str4: string = "", str5: string = "", str6: string = "", str7: string = "", str8: string = "", str9: string = "", str10: string = "") :: string:
  return "%{_str1}%%{_str2}%%{_str3}%%{_str4}%%{_str5}%%{_str6}%%{_str7}%%{_str8}%%{_str9}%%{_str10}%"
function Text_formatText(text: string) :: string:
  if {_text} starts with "st:":
    replace "st:" in {_text} with ""
    set {_text} to Text_toSmallFont({_text})
  return {_text}
function Test_assert(test_id: string, value: object, expected: object):
  set {-tests::%{_test_id}%::value} to "%{_value}%"
  set {-tests::%{_test_id}%::expected} to "%{_expected}%"
  if {_value} = {_expected}:
    Test_announce({_test_id}, true)
  else:
    Test_announce({_test_id}, false)
function Velocity_get(entity: entity) :: vector:
  return {_entity}'s velocity